- [ES5 & ES6](#es5--es6)
	- [1. js 有哪些基本数据类型？](#1-js-有哪些基本数据类型)
	- [2. JavaScript 有几种类型的值？它们在内存中的存储方式时怎样的？](#2-javascript-有几种类型的值它们在内存中的存储方式时怎样的)
	- [3. 什么是 js 的内置对象？](#3-什么是-js-的内置对象)
	- [4. null 和 undefined 的区别？](#4-null-和-undefined-的区别)
	- [5. js 的原型和原型链是什么？&#10084;](#5-js-的原型和原型链是什么)
	- [6. 在 js 中不同进制数字的表示方式?](#6-在-js-中不同进制数字的表示方式)
	- [7. NaN 代表什么意思？](#7-nan-代表什么意思)
	- [8. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？](#8-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字它们之间的区别是什么)
	- [9. 什么情况下会发生布尔值的隐式强制类型转换？](#9-什么情况下会发生布尔值的隐式强制类型转换)
	- [10. 其他值到布尔类型的值的转换规则？](#10-其他值到布尔类型的值的转换规则)
	- [11. `||`和`&&`操作符的返回值？](#11-和操作符的返回值)
	- [12. `==`操作符的强制类型转换规则？](#12-操作符的强制类型转换规则)
	- [13. 常用正则表达式？&#128128;](#13-常用正则表达式)
	- [14. Javascript 的作用域链是什么？](#14-javascript-的作用域链是什么)
	- [15. 写一个通用的事件侦听器函数。](#15-写一个通用的事件侦听器函数)
	- [16. 事件委托是什么？](#16-事件委托是什么)
	- [17. 什么是闭包？&#10084;](#17-什么是闭包)
	- [18. javascript 的严格模式是什么？](#18-javascript-的严格模式是什么)
	- [19. new 操作符具体干了什么？](#19-new-操作符具体干了什么)
	- [20. 对于 JSON 的了解？](#20-对于-json-的了解)
	- [21. js 文件延迟加载的方式有哪些？](#21-js-文件延迟加载的方式有哪些)
	- [22. Ajax 是什么? 如何创建一个 Ajax？&#10084;](#22-ajax-是什么-如何创建一个-ajax)
	- [23. 同源策略的概念和具体限制&#10084;](#23-同源策略的概念和具体限制)
	- [24. js 的几种模块规范？](#24-js-的几种模块规范)
	- [25. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？&#10084;](#25-dom-操作怎样添加移除移动复制创建和查找节点)
	- [26. JavaScript 类数组对象的定义？](#26-javascript-类数组对象的定义)
	- [27. JavaScript 的变量声明提升是什么意思？原因是什么？](#27-javascript-的变量声明提升是什么意思原因是什么)
	- [28. 哪些操作会造成内存泄漏？](#28-哪些操作会造成内存泄漏)
	- [29. 介绍一下 js 的节流与防抖？](#29-介绍一下-js-的节流与防抖)
	- [30. escape,encodeURI,encodeURIComponent 有什么区别？](#30-escapeencodeuriencodeuricomponent-有什么区别)
	- [31. js 中的深浅拷贝是什么意思？](#31-js-中的深浅拷贝是什么意思)
	- [32. get 和 post 请求在缓存方面的区别？](#32-get-和-post-请求在缓存方面的区别)
	- [33. 为什么使用 setTimeout 实现 setInterval？怎么模拟？](#33-为什么使用-settimeout-实现-setinterval怎么模拟)
	- [34. let 和 const 的注意点？&#10084;](#34-let-和-const-的注意点)
	- [35. Set 和 WeakSet 结构是什么？](#35-set-和-weakset-结构是什么)
	- [36. DOM 事件的级别？](#36-dom-事件的级别)
	- [37. DOM 事件模型和事件流？&#10084;](#37-dom-事件模型和事件流)
	- [38. Event 对象的常见 api 方法](#38-event-对象的常见-api-方法)
	- [39. instanceof 的原理](#39-instanceof-的原理)
	- [40. 跨域通信的几种方式&#10084;](#40-跨域通信的几种方式)
	- [41. JS 的事件循环是什么？](#41-js-的事件循环是什么)
	- [42. Class 和普通构造函数有何区别?](#42-class-和普通构造函数有何区别)
	- [43. ES6 有哪些新内容？&#10084;](#43-es6-有哪些新内容)
	- [44. 对 Promise 的理解&#10084;](#44-对-promise-的理解)
	- [45. gulp 是什么？](#45-gulp-是什么)
	- [46. `apply()`，`call()`的作用和区别？](#46-applycall的作用和区别)
	- [47. 合并两个数组的方法](#47-合并两个数组的方法)
	- [48. 函数预编译的步骤](#48-函数预编译的步骤)
	- [49. 函数中 this 的指向](#49-函数中-this-的指向)
	- [50. 拓展运算符的作用？](#50-拓展运算符的作用)
	- [51. 实现一个深拷贝](#51-实现一个深拷贝)
	- [52. 实现对某个元素的拖拽功能](#52-实现对某个元素的拖拽功能)
	- [53. Javascript 全局函数和全局变量](#53-javascript-全局函数和全局变量)
	- [54. `typeof`类型判断的结果](#54-typeof类型判断的结果)
- [框架/库相关](#框架库相关)
	- [1. 什么是 postcss？](#1-什么是-postcss)
	- [2. 什么是 webpack？](#2-什么是-webpack)
	- [3. 微信小程序的架构？](#3-微信小程序的架构)
- [React](#react)
	- [1. 16 版本的 React 生命周期有哪些？](#1-16-版本的-react-生命周期有哪些)
	- [2. setState 是同步的还是异步的？](#2-setstate-是同步的还是异步的)
	- [3. React 的事件系统？](#3-react-的事件系统)
	- [4. 虚拟 DOM 是什么？优劣如何？](#4-虚拟-dom-是什么优劣如何)
	- [5. React 组件的渲染流程是什么？](#5-react-组件的渲染流程是什么)
	- [6. 为什么 React 组件首字母必须大写？](#6-为什么-react-组件首字母必须大写)
	- [7. React 组件通信如何实现?](#7-react-组件通信如何实现)
	- [8. React diff 算法的策略是什么？开发建议？](#8-react-diff-算法的策略是什么开发建议)
	- [9. React 性能优化的方法？](#9-react-性能优化的方法)
	- [10. React Fiber 是什么？](#10-react-fiber-是什么)
	- [11. 原生事件和 React 合成事件的关系？](#11-原生事件和-react-合成事件的关系)
	- [12. redux 的工作流程？](#12-redux-的工作流程)

## ES5 & ES6

### 1. js 有哪些基本数据类型？

js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，Symbol。

### 2. JavaScript 有几种类型的值？它们在内存中的存储方式时怎样的？

基本数据类型存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

引用数据类型存储在堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

### 3. 什么是 js 的内置对象？

js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。

### 4. null 和 undefined 的区别？

undefined 和 null 都是基本数据类型，undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。

### 5. js 的原型和原型链是什么？&#10084;

在 js 中我们使用构造函数来新建一个对象，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，**这个对象包含了可以由该构造函数的所有实例共享的属性和方法**。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。我们可以通过这个方法`Object.getPrototypeOf()`来获取对象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是`Object.prototype` 所以这就是我们新建的对象为什么能够使用`toString()`等方法的原因。

JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

**判断对象类型的方法：**

-   `instanceof`可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype
-   可以通过`Object.prototype.toString.call(xx)`。这样我们就可以获得类似`[object Type]`的字符串。

### 6. 在 js 中不同进制数字的表示方式?

-   以 0X、0x 开头的表示为十六进制。

-   以 0、0O、0o 开头的表示为八进制。

-   以 0B、0b 开头的表示为二进制格式。

### 7. NaN 代表什么意思？

NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值。

### 8. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？

解析允许字符串（如`parseInt()`）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如`Number ()`）不允许出现非数字字符，否则会失败并返回 NaN。

### 9. 什么情况下会发生布尔值的隐式强制类型转换？

-   `if ()`语句中的条件判断表达式。
-   `for (;;)` 语句中的条件判断表达式（第二个）。
-   `while()` 和 `do{}while()`循环中的条件判断表达式。
-   `? :`中的条件判断表达式。
-   逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数。

### 10. 其他值到布尔类型的值的转换规则？

-   undefined
-   null
-   false
-   +0、-0
-   NaN
-   ""

以上为假值，假值的布尔强制类型转换结果为 false。

### 11. `||`和`&&`操作符的返回值？

`||`和`&&`首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。对于`||`来说，如果条件判断结果为`true`就返回第一个操作数的值，如果为 `false`就返回第二个操作数的值。`&&`正好相反。

因此`||`和`&&`返回它们其中一个操作数的值，而非条件判断的结果，这个特性常用于实际开发。

### 12. `==`操作符的强制类型转换规则？

-   字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。
-   其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。
-   `null`和`undefined`之间的相等比较，结果为真。其他值和它们进行比较都返回假值。
-   对象和非对象之间的相等比较，对象先调用`ToPrimitive`抽象操作后，再进行比较。
-   如果一个操作值为`NaN`，则相等比较返回 false。
-   如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作值都指向同一个对象，则相等操作符返回`true`，否则，返回`false`。

### 13. 常用正则表达式？&#128128;

```javascript
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;

//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;

//手机号正则
var mPattern = /^1[34578]\d{9}$/;

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;

//URL正则
var urlP = /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;

//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
```

### 14. Javascript 的作用域链是什么？

作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问**，通过作用域链，我们可以访问到外层环境的变量和函数。

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

### 15. 写一个通用的事件侦听器函数。

```js
const EventUtils = {
	// 视能力分别使用dom0||dom2||IE方式 来绑定事件
	// 添加事件
	addEvent: function (element, type, handler) {
		if (element.addEventListener) {
			element.addEventListener(type, handler, false);
		} else if (element.attachEvent) {
			element.attachEvent('on' + type, handler);
		} else {
			element['on' + type] = handler;
		}
	},

	// 移除事件
	removeEvent: function (element, type, handler) {
		if (element.removeEventListener) {
			element.removeEventListener(type, handler, false);
		} else if (element.detachEvent) {
			element.detachEvent('on' + type, handler);
		} else {
			element['on' + type] = null;
		}
	},

	// 获取事件目标
	getTarget: function (event) {
		return event.target || event.srcElement;
	},

	// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
	getEvent: function (event) {
		return event || window.event;
	},

	// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
	stopPropagation: function (event) {
		if (event.stopPropagation) {
			event.stopPropagation();
		} else {
			event.cancelBubble = true;
		}
	},

	// 取消事件的默认行为
	preventDefault: function (event) {
		if (event.preventDefault) {
			event.preventDefault();
		} else {
			event.returnValue = false;
		}
	},
};
```

### 16. 事件委托是什么？

事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

### 17. 什么是闭包？&#10084;

闭包是指**有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

通过使用闭包，我们可以通过在外部调用闭包函数，从而实现在全局作用域中访问局部作用域中的变量，可以使用这种方法来**创建私有变量**。闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数**保留了这个变量对象的引用**，所以这个变量对象不会被回收。

**闭包使用场景：**

-   把回调（事件触发时调用的函数）绑定到事件上（在内存中维持变量，缓存数据，延迟执行）
-   模拟私有变量（保护函数内变量的安全）

### 18. javascript 的严格模式是什么？

`use strict;`指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。

-   显式报错：设置字符串的`length`属性，函数参数重名
-   增强的安全措施：全局变量必须显式声明，函数内`this`不再指向全局对象
-   静态绑定：禁止使用`with`，`arguments`不再追踪参数的变化

### 19. new 操作符具体干了什么？

1. 创建一个新的空对象。
2. 设置原型，将对象的原型设置为函数的 prototype 对象。
3. 让函数的 this 指向这个对象，执行构造函数的代码。
4. 判断函数的返回值类型，如果是值类型，返回创建的对象；如果是引用类型，就返回这个引用类型的对象。

### 20. 对于 JSON 的了解？

JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。

JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

JSON.stringify() 将 js 对象转换为一个 JSON 字符串。JSON.parse() 将 JSON 格式的字符串转换为一个 js 对象。

### 21. js 文件延迟加载的方式有哪些？

-   将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

-   给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。

-   给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

-   动态创建 DOM 标签，对文档的加载事件进行监听，当文档加载完成后再创建 script 标签来引入 js 脚本。

### 22. Ajax 是什么? 如何创建一个 Ajax？&#10084;

Ajax 是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通请求，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面。

创建 Ajax 的步骤：

1. 创建 XMLHttpRequest 对象，即异步对象。
2. 使用 open 方法创建请求，并指定请求的方法、url 及是否异步。
3. 发送请求。
4. 注册事件。
5. 获取返回的数据。
6. 使用 js 实现局部刷新。

```js
// 异步对象
var xhr = new XMLHttpRequest();
// 设置属性
xhr.open('post', 'post.php');
// 如果想要使用post提交数据,必须添加此行
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
// 将数据通过send方法传递
xhr.send('name=fox&age=18');
// 发送并接受返回值
xhr.onreadystatechange = function () {
	// 这步为判断服务器是否正确响应
	if (xhr.readyState == 4 && xhr.status == 200) {
		console.log(xhr.responseText);
		// 修改页面的显示
		document.querySelector('h1').innerHTML = xhr.responseText;
	}
};
```

### 23. 同源策略的概念和具体限制&#10084;

同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。

源包括三个部分：协议、域名、端口。如果有任何一个部分不同，则源不同，那就是跨域了。

限制;

-   Cookie、LocalStorage 和 IndexDB 无法获取。
-   无法获取和操作 DOM。
-   不能发送 Ajax 请求。

### 24. js 的几种模块规范？

-   **CommonJS** 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
-   **AMD** 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。
-   **CMD** 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。
-   **ES6** 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。

### 25. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？&#10084;

```js
//创建新节点
createDocumentFragment(node);
createElement(node);
createTextNode();

//添加、移除、替换、插入
appendChild(node);
removeChild(node);
replaceChild(node);
insertBefore(node);

//查找
getElementById();
getElementsByName();
getElementsByTagName();
getElementsByClassName();
querySelector();
querySelectorAll();

//属性操作
getAttribute(key);
setAttribute(key, value);
hasAttribute(key);
removeAttribute(key);
```

### 26. JavaScript 类数组对象的定义？

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。

常见的类数组对象有 arguments 和 DOM 方法的返回结果。

### 27. JavaScript 的变量声明提升是什么意思？原因是什么？

变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。

造成变量声明提升的本质原因是 **js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象**。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。

### 28. 哪些操作会造成内存泄漏？

-   第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

-   第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

-   第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。

-   第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

### 29. 介绍一下 js 的节流与防抖？

函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。

函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。

```js
//函数防抖的实现
function debounce(fn, wait) {
	var timer = null;

	return function () {
		var context = this,
			args = arguments;
		//如果此时定时器存在，则取消之前的定时器重新计时
		if (timer) {
			clearTimeout(timer);
			timer = null;
		}
		//设置定时器
		timer = setTimeout(() => {
			fn.apply(context, args);
		}, wait);
	};
}

//函数节流的实现
function throttle(fn, delay) {
	var preTime = Date.now();

	return function () {
		var context = this,
			args = arguments,
			nowTime = Date.now();

		if (nowTime - preTime >= delay) {
			preTime = Date.now();
			return fn.apply(context, args);
		}
	};
}
```

### 30. escape,encodeURI,encodeURIComponent 有什么区别？

encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。

encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。

escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。

### 31. js 中的深浅拷贝是什么意思？

浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 `Object.assign`和展开运算符来实现。

深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。

### 32. get 和 post 请求在缓存方面的区别？

缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。

### 33. 为什么使用 setTimeout 实现 setInterval？怎么模拟？

setInterval 指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。如果某次执行耗时特别长，超过了间隔的时间，那么它结束后，下一次执行就会立即开始。

针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。

```js
function mySetInterval(fn, timeout){
    var timer = {
        flag = true;
    };
    function interval(){
        if(timer.flag){
            fn();
            setTimeout(interval,timeout);
        }
    }
    setTimeout(interval,timeout);
    return timer;
}
```

### 34. let 和 const 的注意点？&#10084;

-   声明的变量只在声明时的代码块内有效
-   不存在变量提升，在声明前使用会报错
-   暂时性死区：在当前作用域中如果存在 let 或 const 声明，所声明的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量
-   不允许在相同作用域内重复声明同一个变量（不能在函数内部重新声明参数）
-   let、const、class 声明的全局变量，不属于顶层对象的属性

### 35. Set 和 WeakSet 结构是什么？

-   ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
-   WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用.

### 36. DOM 事件的级别？

```js
//DOM0 的写法：
element.onclick = function () {};
//DOM2 的写法：
//上面的第三参数中，true表示事件在捕获阶段触发，false表示事件在冒泡阶段触发（默认）
element.addEventListener('click', function () {}, false);
//DOM3 的写法：
//DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。
element.addEventListener('keyup', function () {}, false);
```

### 37. DOM 事件模型和事件流？&#10084;

DOM 事件模型指的是捕获和冒泡，捕获是从上往下，冒泡是从下（目标元素）往上。

DOM 事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的：

1. 捕获： 从 window 对象传到目标元素。
2. 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。
3. 冒泡：从目标元素传到 Window 对象。

捕获阶段，事件传递的顺序是：

window --> document --> html--> body --> 父元素、子元素、目标元素

### 38. Event 对象的常见 api 方法

-   `event.preventDefault()`：阻止默认事件。
-   `event.stopPropagation()`：阻止冒泡。
-   `event.stopImmediatePropagation();`：设置事件优先级。
-   `event.currentTarget`和`event.target`：分别表示当前所绑定的事件对象和当前被点击的元素，常用于事件委托。

### 39. instanceof 的原理

`instanceof`用于判断实例属于哪个构造函数。

原理：判断实例对象的**proto**属性，和构造函数的 prototype 属性，是否为同一个引用。

### 40. 跨域通信的几种方式&#10084;

-   JSONP：通过`<script>`标签的`src`属性向服务器请求一个脚本，服务器根据`callback`参数告知的回调函数名，将 JSON 数据作为该回调函数的参数返回。
-   WebSocket：一种通信协议，服务器可以根据请求头信息中的`Origin`字段判断是否许可本次通讯，所以不实行同源政策，需要后端启动 websocket 服务。
-   CORS：跨域资源共享，支持所有类型的请求，需要服务器实现 CORS 接口。
-   代理：因为同源策略只是浏览器需要遵行的规则，可以设置一个代理服务器转发浏览器的请求和服务器的响应，这种方法不需要后端配合。

### 41. JS 的事件循环是什么？

1. 所有同步任务都在主线程上执行，形成一个执行栈。

2. 主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

4. 主线程不断重复上面的第三步。

### 42. Class 和普通构造函数有何区别?

-   Class 在语法上更加贴合面向对象的写法
-   Class 实现继承更加易读、易理解
-   更易于写 java 等后端语言的使用
-   本质还是语法糖，使用 prototype

### 43. ES6 有哪些新内容？&#10084;

-   let 和 const 声明
-   变量的解构赋值
-   拓展运算符
-   原有对象的新增方法
-   Symbol
-   Set 和 Map 数据结构
-   Promise 对象
-   for of 遍历
-   class
-   async 函数
-   模块的引入

### 44. 对 Promise 的理解&#10084;

Promise 对象可以用同步的表现形式来书写异步代码，使用 Promise 主要有以下好处：

-   解决回调地狱的问题（层层嵌套的回调函数）
-   语法非常简洁、可读性强

基本用法：

1. 使用 new 实例化一个 Promise 对象，在 Promise 的构造函数中传递一个函数用于处理异步任务。
2. 函数中传入两个参数：resolve 和 reject，分别表示异步执行成功后的回调函数和异步执行失败后的回调函数。
3. 通过 promise.then() 处理返回结果。

```js
//使用Promise封装Ajax请求

const request = require('request');
// Promise 封装接口
function request1() {
	return new Promise((resolve, reject) => {
		request('https://www.baidu.com', function (response) {
			if (response.retCode == 200) {
				// 这里的 response 是接口1的返回结果
				resolve('request1 success' + response);
			} else {
				reject('接口请求失败');
			}
		});
	});
}

request1().then((res1) => {
	// 接口1请求成功后，打印接口1的返回结果
	console.log(res1);
	return request2();
});
```

### 45. gulp 是什么？

gulp 是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成。

流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向。

### 46. `apply()`，`call()`的作用和区别？

**作用：**

-   改变 this 指向
-   借用其他对象的方法

**区别：**

传入参数不同，第一个参数都为 this 指向，第二个参数`apply()`传入一个类数组，`call()`传入的参数数量不固定，从第二个参数开始往后,每个参数被依次传入函数。

### 47. 合并两个数组的方法

```js
var a = [1, 3, 4];
var b = [7, 5];

// 第一种，使用concat
var c = a.concat(b);

//第二种，for循环
for (let value of b) {
	a.push(value);
}

//第三种,apply
a.push().apply(a, b);

//第四种，扩展运算符
var c = [...a, ...b];
```

### 48. 函数预编译的步骤

1. 创建 AO 对象。
2. 找形参和变量声明，将形参名和变量作为 AO 的属性名，值为 undefined。
3. 将实参值和形参统一，实参的值赋给形参。
4. 查找函数声明，函数名作为 AO 对象的属性名，值为整个函数体。

```js
function fn(a) {
	console.log(a); // 输出functiona(){}
	var a = 123; //执行到这里重新对a赋，AO对象再一次更新
	console.log(a); // 输出123

	function a() {} //预编译环节已经进行了变量提升，故执行时不在看这行代码
	console.log(a); // 输出123

	var b = function () {}; //这个是函数表达式不是函数声明，故不能提升，会对AO中的b重新赋值
	console.log(b); //输出function(){}

	function d() {}
}
```

参考：[预编译及变量提升详解](https://juejin.im/post/6844903575571677198)

### 49. 函数中 this 的指向

-   以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window
-   以方法的形式调用时，this 指向调用方法的那个对象
-   以构造函数的形式调用时，this 指向实例对象
-   以事件绑定函数的形式调用时，this 指向绑定事件的对象
-   使用 call 和 apply 调用时，this 指向指定的那个对象
-   箭头函数不会创建自己的 this,它只会从自己的作用域链的上一层继承 this，并且绑定定义时的对象，而不是运行时的对象

### 50. 拓展运算符的作用？

-   替代 apply `Math.max(...[args])`、`arr1.push(...arr2)`
-   复制数组 `const a2 = [...a1]`
-   合并数组（浅拷贝） `[...arr1,...arr2,...arr3]`
-   将字符串转为真正的数组 `[...'hello']`

### 51. 实现一个深拷贝

```js
function deepCopy(p, c) {
	var c = c || {};

	for (var i in p) {
		if (typeof p[i] === 'object') {
			c[i] = p[i].constructor === Array ? [] : {};
			deepCopy(p[i], c[i]);
		} else {
			c[i] = p[i];
		}
	}

	return c;
}
```

### 52. 实现对某个元素的拖拽功能

-   给需要拖拽的节点绑定 mousedown, mousemove, mouseup 事件
-   mousedown 事件触发后，开始拖拽
-   mousemove 时，需要通过 event.clientX 和 clientY 获取拖拽位置，并实时更新位置
-   mouseup 时，拖拽结束
-   需要注意浏览器边界的情况

### 53. Javascript 全局函数和全局变量

**全局变量：**

-   Infinity 代表正的无穷大的数值。
-   NaN 指示某个值是不是数字值。
-   undefined 指示未定义的值。

**全局函数：**

-   decodeURI() 解码某个编码的 URI。
-   decodeURIComponent() 解码一个编码的 URI 组件。
-   encodeURI() 把字符串编码为 URI。
-   encodeURIComponent() 把字符串编码为 URI 组件。
-   escape() 对字符串进行编码。
-   eval() 计算 JavaScript 字符串，并把它作为脚本代码来执行。
-   isFinite() 检查某个值是否为有穷大的数。
-   isNaN() 检查某个值是否是数字。
-   Number() 把对象的值转换为数字。
-   parseFloat() 解析一个字符串并返回一个浮点数。
-   parseInt() 解析一个字符串并返回一个整数。
-   String() 把对象的值转换为字符串。
-   unescape() 对由 escape() 编码的字符串进行解码

### 54. `typeof`类型判断的结果

```js
typeof 1; // 'number'
typeof '1'; // 'string'
typeof undefined; // 'undefined'
typeof null; // 结果为'object'，历史遗留问题
typeof true; // 'boolean'
typeof Symbol(); // 'symbol'
typeof []; // 'object'
typeof {}; // 'object'
typeof console.log; // 'function'
typeof b; // b 没有声明，但是还会显示 undefined
```

## 框架/库相关

### 1. 什么是 postcss？

postcss 可以看成是一个平台，它提供了一个解析器，能够将 CSS 解析成抽象语法树。在这个平台上可以开发和使用插件来处理 css，比如自动加浏览器前缀，处理预处理器生成的文件等等。

### 2. 什么是 webpack？

webpack 是一个模块打包工具，可以使用 webpack 管理模块依赖，并编绎输出模块所需的静态文件。它能够很好地管理、打包 Web 开发中所用到的 HTML、Javascript、CSS 以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack 有对应的模块加载器。webpack 模块打包器会分析模块间的依赖关系，最后生成了优化且合并后的静态资源。

### 3. 微信小程序的架构？

移动应用开发模式：把 H5 所有代码打包，一次性 Load 到本地再打开。这样的好处是可以用一种近似 Web 的方式来开发，同时在体验上也可以做到不错的效果，并且可以做到云端更新。

安全问题：把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，开发者就没法直接操作 Dom。

架构：渲染层（Webview） + 逻辑层（JSCore）+ 系统层（Native）。渲染层用 Webview 进行渲染，开发者的 JS 逻辑运行在一个独立的 JSCore 线程。渲染层提供了带有数据绑定语法的 WXML，逻辑层提供了 setData 等等 API，开发者需要进行界面变化时，只需要通过 setData 把变化的数据传进去，小程序框架就会进行 Dom Diff 等流程最后把正确的结果更新在 Dom 树上。两个线程各自注入了一份基础库，渲染层的基础库含有 VD 的处理以及底层组件系统的机制，对上层提供一些内置组件，例如 video、image 等等。逻辑层的基础库主要会提供给上层一些 API，例如大家经常用到的 wx.login、wx.getSystemInfo 等等。渲染层和逻辑层通过系统层的 WeixinJSBridge 进行通信。

## React

### 1. 16 版本的 React 生命周期有哪些？

React16 新的生命周期弃用了 componentWillMount、componentWillReceivePorps，componentWillUpdate 新增了 getDerivedStateFromProps、getSnapshotBeforeUpdate。

初始化阶段：

-   constructor 构造函数
-   getDefaultPropsprops props 默认值
-   getInitialStatestate state 默认值

挂载阶段：

-   getDerivedStateFromProps(props,state) 返回新的 state
-   render 组件渲染
-   componentDidMount 组件挂载到 DOM 后调用

更新阶段：

-   getDerivedStateFromProps(props,state) 返回新的 state
-   shouldComponentUpdate 组件是否需要更新
-   render 组件渲染
-   getSnapshotBeforeUpdate(prevProps,prevState) 返回值作为 componentDidUpdate 的第三个参数
-   componentDidUpdate 组件更新后调用

卸载阶段：

-   componentWillUnmount 组件卸载前调用

错误处理：

-   componentDidCatch

### 2. setState 是同步的还是异步的？

在生命周期和合成事件中， react 仍然处于它的更新机制中，这时无论调用多少次 setState，都会不会执行更新，而是将要更新的 state 暂存。当上一次更新机制执行完毕，再执行之前累积的 setState。所以这时表现出来就是异步的。

在异步代码和原生事件中，根据 JavaScript 的异步机制，会将异步代码先暂存，等所有同步代码执行完毕后在执行，这时上一次更新机制已经走完，这时再调用 setState 即可立即执行更新，拿到更新后的结果。

setState 的第二个参数接收一个函数，该函数会在 React 的批处理机制完成之后调用，所以如果想在调用 setState 后立即获取更新后的值，可以在该回调函数中获取。

### 3. React 的事件系统？

-   当在 jsx 中绑定事件时，React 并不是将该事件绑在它的真实 DOM 节点上，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。（React 17 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器 root 中）

-   React 中的合成事件是对浏览器原生事件的跨浏览器包装，使得事件在所有浏览器中的工作行为相同。

-   React 事件要自己绑定 this 的原因是事件处理函数并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的 this 是不准确的。

### 4. 虚拟 DOM 是什么？优劣如何？

-   虚拟 DOM 本质上是 JavaScript 对象，是对真实 DOM 的抽象
-   状态变更时，比较新树和旧树的差异
-   最后把差异更新到真正的 dom 中

优点：

-   保证性能下限
-   无需手动操作 DOM
-   跨平台

缺点：

-   无法进行极致优化，比不上手动操作 DOM 进行极端优化

### 5. React 组件的渲染流程是什么？

-   使用 React.createElement 或 JSX 编写 React 组件，实际上所有的 JSX 代码最后都会转换成 React.createElement(...)， Babel 帮助我们完成了这个转换的过程。

-   createElement 函数对 key 和 ref 等特殊的 props 进行处理，并获取 defaultProps 对默认 props 进行赋值，并且对传入的孩子节点进行处理，最终构造成一个 ReactElement 对象（所谓的虚拟 DOM）。

-   ReactDOM.render 将生成好的虚拟 DOM 渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实 DOM。

### 6. 为什么 React 组件首字母必须大写？

babel 在编译时会判断 JSX 中组件的首字母，当首字母为小写时，其被认定为原生 DOM 标签， createElement 的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件， createElement 的第一个变量被编译为对象。

### 7. React 组件通信如何实现?

-   父组件向子组件通讯: 通过传 props 的方式，向子组件进行通讯

-   子组件向父组件通讯: 父组件向子组件传递 props 进行通讯，此 props 为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中

-   兄弟组件通信: 找到这两个兄弟节点共同的父节点，结合上面两种方式由父节点转发信息进行通信

-   跨层级通信: Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言, 对于跨越多层的全局数据通过 Context 通信再适合不过

-   全局状态管理工具: 借助 Redux 等全局状态管理工具进行通信，这种工具会维护一个全局状态中心 Store，并根据不同的事件产生新的状态

### 8. React diff 算法的策略是什么？开发建议？

-   tree diff：对树分层比较，只对同一层级节点进行比较，如果节点不存在，就删除该节点及其子节点，不进一步比较。如果发生跨层级的位置变化，就在新位置创建相同的节点并删除原位置上的节点。
-   component diff：对不同组件的比较，同一类型的组件按照 tree diff 策略比较，可以用 shouldComponentUpdate() 判断虚拟 DOM 有无改变；对于不同类型的组件，将一个组件判断为脏组件，替换整个组件的所有节点。
-   element diff：同一层次的一组节点提供删除、插入、移动三种操作，使用 key 属性区分节点。

开发建议：

-   注意保持 dom 结构的稳定，减少跨层级的变化。
-   可以通过 css 隐藏或显示节点，而不是真的移除或添加 dom 节点。
-   注意使用 shouldComponentUpdate() 来减少不必要的更新。
-   对于类似的结构尽量封装成组件，既减少代码量，又能减少 diff 的性能消耗。
-   对于列表结构，尽量减少频繁移动节点的操作。

### 9. React 性能优化的方法？

-   少用 setState。
-   使用生命周期 shouldComponentUpdate 或 PureComponent：shouldComponentUpdate 接收两个参数 nextProps 和 nextState，返回一个布尔值表示是否更新组件。PureComponent 会进行浅比较来判断组件是否应该重新渲染，对于传入的基本类型 props，只要值相同，浅比较就会认为相同，对于传入的引用类型 props，浅比较只会判断传入的 props 是不是同一个引用。（父组件的更新会导致其子组件也重新渲染，不论传入子组件的 props 是否改变）
-   合理拆分组件：在对组件拆分之后，render 的粒度会更加精细，性能也能得到一定的提升。
-   props 尽量只传组件使用到的数据，避免多余的更新。
-   使用 React.Memo 缓存组件：通过存储昂贵的函数调用的结果，并在再次发生相同的输入时返回缓存的结果，以此来加速程序。
-   使用 React.Lazy 和 React.Suspense 延迟加载不是立即需要的组件。

### 10. React Fiber 是什么？

React Fiber 是一种基于浏览器的单线程调度算法.。React Fiber 把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。

### 11. 原生事件和 React 合成事件的关系？

React 的所有事件都通过 document 进行统一分发。当真实 Dom 触发事件后冒泡到 document 后才会对 React 事件进行处理。

所以原生的事件会先执行，然后执行 React 合成事件，最后执行真正在 document 上挂载的事件.

React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。

### 12. redux 的工作流程？

**核心概念：**

-   Store：保存数据的地方，整个应用只能有一个 Store。
-   State：Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫做 State。
-   Action：一个用于描述要干什么动作的普通对象。
-   Action Creator：定义一个函数来生成 Action，这个函数就叫 Action Creator。
-   Reducer：根据 Action 动作的不同，对 store 的 state 做处理的一个纯函数。
-   dispatch：是 View 发出 Action 的唯一方法。

**三大原则：**

-   数据应该有且仅有一个源头
-   state 应该是只读的
-   使用纯函数进行更改

**工作流程：**

1. 用户使用 dispatch 发出 Action。
2. Store 调用 Reducer 计算后返回新的 State。
3. State 一旦有变化，Store 就会调用监听函数来更新 View。
