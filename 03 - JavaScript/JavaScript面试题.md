- [1. 介绍一下 js 的基本数据类型。](#1-介绍一下-js-的基本数据类型)
- [2. JavaScript 有几种类型的值？它们在内存中的存储方式时怎样的？](#2-javascript-有几种类型的值它们在内存中的存储方式时怎样的)
- [3. 什么是 js 的内置对象？](#3-什么是-js-的内置对象)
- [4. null 和 undefined 的区别？](#4-null-和-undefined-的区别)
- [5. **js 的原型和原型链是什么？**](#5-js-的原型和原型链是什么)
- [6. 在 js 中不同进制数字的表示方式?](#6-在-js-中不同进制数字的表示方式)
- [7. NaN 代表什么意思？](#7-nan-代表什么意思)
- [8. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？](#8-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字它们之间的区别是什么)
- [9. 什么情况下会发生布尔值的隐式强制类型转换？](#9-什么情况下会发生布尔值的隐式强制类型转换)
- [10. 其他值到布尔类型的值的转换规则？](#10-其他值到布尔类型的值的转换规则)
- [11. `||`和`&&`操作符的返回值？](#11-和操作符的返回值)
- [12. `==`操作符的强制类型转换规则？](#12-操作符的强制类型转换规则)
- [13. 常用正则表达式？](#13-常用正则表达式)
- [14. Javascript 的作用域链是什么？](#14-javascript-的作用域链是什么)
- [15. eval 是做什么的？](#15-eval-是做什么的)
- [16. 什么是 DOM 和 BOM？](#16-什么是-dom-和-bom)
- [17. 写一个通用的事件侦听器函数。](#17-写一个通用的事件侦听器函数)
- [17. 事件委托是什么？](#17-事件委托是什么)
- [18. 什么是闭包?](#18-什么是闭包)
- [19. javascript 的严格模式是什么？](#19-javascript-的严格模式是什么)
- [20. new 操作符具体干了什么？](#20-new-操作符具体干了什么)
- [21. 对于 JSON 的了解？](#21-对于-json-的了解)
- [22. js 延迟加载的方式有哪些？](#22-js-延迟加载的方式有哪些)
- [23. **Ajax 是什么? 如何创建一个 Ajax？**](#23-ajax-是什么-如何创建一个-ajax)
- [24. **同源策略的概念和具体限制**](#24-同源策略的概念和具体限制)
- [25. js 的几种模块规范？](#25-js-的几种模块规范)
- [26. AMD 和 CMD 规范的区别？](#26-amd-和-cmd-规范的区别)
- [27. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？](#27-dom-操作怎样添加移除移动复制创建和查找节点)
- [28. JavaScript 类数组对象的定义？](#28-javascript-类数组对象的定义)
- [29. JavaScript 的变量声明提升是什么意思？原因是什么？](#29-javascript-的变量声明提升是什么意思原因是什么)
- [30. 哪些操作会造成内存泄漏？](#30-哪些操作会造成内存泄漏)
- [31. 如何判断当前脚本运行在浏览器还是 node 环境中？](#31-如何判断当前脚本运行在浏览器还是-node-环境中)
- [32. 介绍一下 js 的节流与防抖？](#32-介绍一下-js-的节流与防抖)
- [33. `Object.is()` 与原来的比较操作符 “===”、“==” 的区别？](#33-objectis-与原来的比较操作符--的区别)
- [34. escape,encodeURI,encodeURIComponent 有什么区别？](#34-escapeencodeuriencodeuricomponent-有什么区别)
- [35. js 中的深浅拷贝是什么意思？](#35-js-中的深浅拷贝是什么意思)
- [36. vue 双向数据绑定原理？](#36-vue-双向数据绑定原理)
- [37. Js 动画与 CSS 动画区别？](#37-js-动画与-css-动画区别)
- [38. URL 和 URI 的区别？](#38-url-和-uri-的区别)
- [39. get 和 post 请求在缓存方面的区别？](#39-get-和-post-请求在缓存方面的区别)
- [40. js 拖拽功能的实现？](#40-js-拖拽功能的实现)
- [41. 为什么使用 setTimeout 实现 setInterval？怎么模拟？](#41-为什么使用-settimeout-实现-setinterval怎么模拟)
- [42. let 和 const 的注意点？](#42-let-和-const-的注意点)
- [43. Set 和 WeakSet 结构是什么？](#43-set-和-weakset-结构是什么)
- [44. 如何检测浏览器所支持的最小字体大小？](#44-如何检测浏览器所支持的最小字体大小)
- [44. Vue 的生命周期是什么？各个生命阶段是什么？](#44-vue-的生命周期是什么各个生命阶段是什么)
- [45. **DOM 事件的级别？**](#45-dom-事件的级别)
- [46. **DOM 事件模型和事件流？**](#46-dom-事件模型和事件流)
- [47. **Event 对象的常见 api 方法**](#47-event-对象的常见-api-方法)
- [48. **instance of 的原理**](#48-instance-of-的原理)
- [49. **使用 new 运算符时发生了什么？**](#49-使用-new-运算符时发生了什么)
- [50. **跨域通信的几种方式**](#50-跨域通信的几种方式)
- [51. **JS 的异步和单线程如何理解**](#51-js-的异步和单线程如何理解)

### 1. 介绍一下 js 的基本数据类型。

js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 类型，代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。

### 2. JavaScript 有几种类型的值？它们在内存中的存储方式时怎样的？

基本数据类型存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

引用数据类型存储在堆（heap）中，占据空间大、大小不固定。引用数据类型在
栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

### 3. 什么是 js 的内置对象？

js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。

### 4. null 和 undefined 的区别？

undefined 和 null 都是基本数据类型，undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。

### 5. **js 的原型和原型链是什么？**

在 js 中我们使用构造函数来新建一个对象，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。我们可以通过这个方法`Object.getPrototypeOf()`来获取对象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是`Object.prototype` 所以这就是我们新建的对象为什么能够使用`toString()`等方法的原因。

JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

### 6. 在 js 中不同进制数字的表示方式?

- 以 0X、0x 开头的表示为十六进制。

- 以 0、0O、0o 开头的表示为八进制。

- 以 0B、0b 开头的表示为二进制格式。

### 7. NaN 代表什么意思？

NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

```javascript
typeof NaN; // "number"
```

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值。

### 8. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？

解析允许字符串（如`parseInt()`）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如`Number ()`）不允许出现非数字字符，否则会失败并返回 NaN。

### 9. 什么情况下会发生布尔值的隐式强制类型转换？

- `if ()`语句中的条件判断表达式。
- `for (;;)` 语句中的条件判断表达式（第二个）。
- `while()` 和 `do{}while()`循环中的条件判断表达式。
- `? :`中的条件判断表达式。
- 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数。

### 10. 其他值到布尔类型的值的转换规则？

- undefined
- null
- false
- +0、-0 和 NaN
- ""

以上为假值。假值的布尔强制类型转换结果为 false，从逻辑上说，假值列表以外的都应该是真值。

### 11. `||`和`&&`操作符的返回值？

`||`和`&&`首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。对于`||`来说，如果条件判断结果为`true`就返回第一个操作数的值，如果为 `false`就返回第二个操作数的值。`&&`正好相反。

因此`||`和`&&`返回它们其中一个操作数的值，而非条件判断的结果，这个特性常用于实际开发。

### 12. `==`操作符的强制类型转换规则？

- 字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。
- 其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。
- `null`和`undefined`之间的相等比较，结果为真。其他值和它们进行比较都返回假值。
- 对象和非对象之间的相等比较，对象先调用`ToPrimitive`抽象操作后，再进行比较。
- 如果一个操作值为`NaN`，则相等比较返回 false。
- 如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作值都指向同一个对象，则相等操作符返回`true`，否则，返回`false`。

### 13. 常用正则表达式？

```javascript
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;

//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;

//手机号正则
var mPattern = /^1[34578]\d{9}$/;

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;

//URL正则
var urlP = /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;

//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
```

### 14. Javascript 的作用域链是什么？

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

### 15. eval 是做什么的？

它的功能是把对应的字符串解析成 JS 代码并运行。应该避免使用 eval，不安全，非常耗性能。

### 16. 什么是 DOM 和 BOM？

DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。

BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。

### 17. 写一个通用的事件侦听器函数。

```js
const EventUtils = {
  // 视能力分别使用dom0||dom2||IE方式 来绑定事件
  // 添加事件
  addEvent: function (element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent("on" + type, handler);
    } else {
      element["on" + type] = handler;
    }
  },

  // 移除事件
  removeEvent: function (element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, handler);
    } else {
      element["on" + type] = null;
    }
  },

  // 获取事件目标
  getTarget: function (event) {
    return event.target || event.srcElement;
  },

  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
  getEvent: function (event) {
    return event || window.event;
  },

  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
  stopPropagation: function (event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  },

  // 取消事件的默认行为
  preventDefault: function (event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  },
};
```

### 17. 事件委托是什么？

事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

### 18. 什么是闭包?

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。

闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

### 19. javascript 的严格模式是什么？

`use strict;`指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。

### 20. new 操作符具体干了什么？

1. 创建一个新的空对象。
2. 设置原型，将对象的原型设置为函数的 prototype 对象。
3. 让函数的 this 指向这个对象，执行构造函数的代码。
4. 判断函数的返回值类型，如果是值类型，返回创建的对象；如果是引用类型，就返回这个引用类型的对象。

### 21. 对于 JSON 的了解？

JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。

在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。

因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。

另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。

### 22. js 延迟加载的方式有哪些？

- 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

- 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。

- 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

- 动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。

### 23. **Ajax 是什么? 如何创建一个 Ajax？**

Ajax 是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通请求，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面。

创建 Ajax 的步骤：

1. 创建 XMLHttpRequest 对象，即异步对象。
2. 使用 open 方法创建请求，并指定请求的方法、url 及是否异步。
3. 发送请求。
4. 注册事件。
5. 获取返回的数据。
6. 使用 js 实现局部刷新。

```js
// 异步对象
var xhr = new XMLHttpRequest();
// 设置属性
xhr.open("post", "post.php");
// 如果想要使用post提交数据,必须添加此行
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
// 将数据通过send方法传递
xhr.send("name=fox&age=18");
// 发送并接受返回值
xhr.onreadystatechange = function () {
  // 这步为判断服务器是否正确响应
  if (xhr.readyState == 4 && xhr.status == 200) {
    console.log(xhr.responseText);
    // 修改页面的显示
    document.querySelector("h1").innerHTML = xhr.responseText;
  }
};
```

### 24. **同源策略的概念和具体限制**

同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。

源包括三个部分：协议、域名、端口。如果有任何一个部分不同，则源不同，那就是跨域了。

限制;

- Cookie、LocalStorage 和 IndexDB 无法获取。
- 无法获取和操作 DOM。
- 不能发送 Ajax 请求。

### 25. js 的几种模块规范？

- CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
- AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。
- CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。
- ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。

### 26. AMD 和 CMD 规范的区别？

- 第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。

- 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。

### 27. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？

```js
//创建新节点
createDocumentFragment(node);
createElement(node);
createTextNode();

//添加、移除、替换、插入
appendChild(node);
removeChild(node);
replaceChild(node);
insertBefore(node);

//查找
getElementById();
getElementsByName();
getElementsByTagName();
getElementsByClassName();
querySelector();
querySelectorAll();

//属性操作
getAttribute(key);
setAttribute(key, value);
hasAttribute(key);
removeAttribute(key);
```

### 28. JavaScript 类数组对象的定义？

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。

常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

### 29. JavaScript 的变量声明提升是什么意思？原因是什么？

变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。

造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。

### 30. 哪些操作会造成内存泄漏？

- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

- 第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

- 第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。

- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

### 31. 如何判断当前脚本运行在浏览器还是 node 环境中？

通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。

```js
this === window ? "browser" : "node";
```

### 32. 介绍一下 js 的节流与防抖？

函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。

函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。

```js
//函数防抖的实现
function debounce(fn, wait) {
  var timer = null;

  return function () {
    var context = this,
      args = arguments;
    //如果此时定时器存在，则取消之前的定时器重新计时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    //设置定时器
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

//函数节流的实现
function throttle(fn, delay) {
  var preTime = Date.now();

  return function () {
    var context = this,
      args = arguments,
      nowTime = Date.now();

    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}
```

### 33. `Object.is()` 与原来的比较操作符 “===”、“==” 的区别？

使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。

使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。

使用`Object.is()`来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。

### 34. escape,encodeURI,encodeURIComponent 有什么区别？

encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。

encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。

escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。

### 35. js 中的深浅拷贝是什么意思？

浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 `Object.assign`和展开运算符来实现。

深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。

### 36. vue 双向数据绑定原理？

vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。

首先我们通过`Object.defineProperty()`方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。

数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。

如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。

如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。

### 37. Js 动画与 CSS 动画区别？

CSS3 动画的优点是在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化代码相对简单。缺点是在动画控制上不够灵活，兼容性不好。

JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧。

### 38. URL 和 URI 的区别？

URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。

URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。

### 39. get 和 post 请求在缓存方面的区别？

缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。

### 40. js 拖拽功能的实现？

一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。

这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态。在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。最后 mouseup 事件触发后，清除状态，结束拖拽事件。

clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，用 offsetX 和 offsetY 来表示元素的元素的初始坐标，因此定位信息为“鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft”。

### 41. 为什么使用 setTimeout 实现 setInterval？怎么模拟？

setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。

针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。

```js
function mySetInterval(fn, timeout){
    var timer = {
        flag = true;
    };
    function interval(){
        if(timer.flag){
            fn();
            setTimeout(interval,timeout);
        }
    }
    setTimeout(interval,timeout);
    return timer;
}
```

### 42. let 和 const 的注意点？

- 声明的变量只在声明时的代码块内有效
- 不存在声明提升
- 存在暂时性死区，如果在变量声明前使用，会报错
- 不允许重复声明，重复声明会报错

### 43. Set 和 WeakSet 结构是什么？

- ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
- WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，

### 44. 如何检测浏览器所支持的最小字体大小？

用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。

### 44. Vue 的生命周期是什么？各个生命阶段是什么？

Vue 的生命周期指的是组件从创建到销毁的一系列的过程。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。

Vue 一共有 8 个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。

### 45. **DOM 事件的级别？**

```js
//DOM0 的写法：
element.onclick = function () {};
//DOM2 的写法：
//上面的第三参数中，true表示事件在捕获阶段触发，false表示事件在冒泡阶段触发（默认）
element.addEventListener("click", function () {}, false);
//DOM3 的写法：
//DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。
element.addEventListener("keyup", function () {}, false);
```

### 46. **DOM 事件模型和事件流？**

DOM 事件模型指的是捕获和冒泡，捕获是从上往下，冒泡是从下（目标元素）往上。

DOM 事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的：

1. 捕获： 从 window 对象传到目标元素。
2. 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。
3. 冒泡：从目标元素传到 Window 对象。

捕获阶段，事件传递的顺序是：

window --> document --> html--> body --> 父元素、子元素、目标元素

### 47. **Event 对象的常见 api 方法**

- `event.preventDefault()`：阻止默认事件。
- `event.stopPropagation()`：阻止冒泡。
- `event.stopImmediatePropagation();`：设置事件优先级。
- `event.currentTarget`和`event.target`：分别表示当前所绑定的事件对象和当前被点击的元素，常用于事件委托。

### 48. **instance of 的原理**

`instance of`用于判断实例属于哪个构造函数。

原理：判断实例对象的**proto**属性，和构造函数的 prototype 属性，是否为同一个引用。

### 49. **使用 new 运算符时发生了什么？**

1. 创建一个新的空对象实例。
2. 将此空对象的隐式原型指向其构造函数的显示原型。
3. 执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。
4. 如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。

### 50. **跨域通信的几种方式**

- JSONP：通过`<script>`标签的异步加载来实现的。比如说，实际开发中，我们发现，head 标签里，可以通过`<script>`标签的 src，里面放 url，加载很多在线的插件，这就是用到了 JSONP。
- WebSocket：

```js
var ws = new WebSocket("wss://echo.websocket.org");
//把请求发出去
ws.onopen = function (evt) {
  console.log("Connection open ...");
  ws.send("Hello WebSockets!");
};
//对方发消息过来时，我接收
ws.onmessage = function (evt) {
  console.log("Received Message: ", evt.data);
  ws.close();
};
//关闭连接
ws.onclose = function (evt) {
  console.log("Connection closed.");
};
```

- CORS：可以理解成是既可以同步、也可以异步的 Ajax。
- Hash：url 的 # 后面的内容就叫 Hash。Hash 的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理（补充：url 的 ? 后面的内容叫 Search。Search 的改变，会导致页面刷新，因此不能做跨域通信）。
- postMessage()：

```js
// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
Bwindow.postMessage("data", "http://B.com"); //这里强调的是B窗口里的window对象

// 在窗口B中监听 message 事件
Awindow.addEventListener(
  "message",
  function (event) {
    //这里强调的是A窗口里的window对象
    console.log(event.origin); //获取 ：url。这里指：http://A.com
    console.log(event.source); //获取：A window对象
    console.log(event.data); //获取传过来的数据
  },
  false
);
```

### 51. **JS 的异步和单线程如何理解**

js 是单线程（同一时间只能做一件事），而且有一个任务队列：全部的同步任务执行完毕后，再来执行异步任务。只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。
