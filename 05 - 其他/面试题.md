## 目录

- [1. 你对浏览器的理解？](#1-你对浏览器的理解)
- [2. 介绍一下你对浏览器内核的理解？](#2-介绍一下你对浏览器内核的理解)
- [3. 常见浏览器内核比较](#3-常见浏览器内核比较)
- [4. 浏览器的渲染原理？](#4-浏览器的渲染原理)
- [5. 渲染过程中遇到 JS 文件怎么处理？](#5-渲染过程中遇到-js-文件怎么处理)
- [6. async 和 defer 的作用是什么？有什么区别？](#6-async-和-defer-的作用是什么有什么区别)
- [7. 什么是文档的预解析？](#7-什么是文档的预解析)
- [8. CSS 如何阻塞文档解析？](#8-css-如何阻塞文档解析)
- [9. 渲染页面时常见哪些不良现象？](#9-渲染页面时常见哪些不良现象)
- [10. 什么是重绘和回流？](#10-什么是重绘和回流)
- [11. 如何减少回流？](#11-如何减少回流)
- [12. DOMContentLoaded 事件和 Load 事件的区别？](#12-domcontentloaded-事件和-load-事件的区别)
- [13. 如何实现浏览器内多个标签页之间的通信?](#13-如何实现浏览器内多个标签页之间的通信)
- [14. 页面可见性（Page Visibility API）可以有哪些用途？](#14-页面可见性page-visibility-api可以有哪些用途)
- [15. 前端性能优化？](#15-前端性能优化)
- [16. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？](#16-扫描二维码登录网页是什么原理前后两个事件是如何联系的)

### 1. 你对浏览器的理解？

浏览器的主要功能是将用户选择的 web 资源呈现出来，它利用 URL 从服务器请求需要的资源，并将其显示在浏览器窗口中。

浏览器可以分为两部分，shell 和 内核。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核是浏览器的核心，是基于标记语言显示内容的程序或模块。

W3C 负责制定 web 的标准，浏览器厂商根据这些规范开发浏览器。但是由于它们经常开发自己的扩展，对规范的遵循并不完善，所以带来了严重的兼容性问题。

### 2. 介绍一下你对浏览器内核的理解？

主要分成两部分：渲染引擎和 JS 引擎。

渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件浏览器扩展显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。

JS 引擎：解析和执行 javascript 来实现网页的动态效果。

### 3. 常见浏览器内核比较

- **Trident**：IE 浏览器用的内核，由于早期 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决.
- **Presto**：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快 3 倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。
- **Gecko**：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。
- **Webkit**：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。
- **Blink**：Blink 是 Webkit 的一个分支。Blink 现在是谷歌公司与 Opera Software 共同研发。Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。

### 4. 浏览器的渲染原理？

1. 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
2. 然后对 CSS 进行解析，生成 CSSOM 规则树。
3. 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应。
4. 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
5. 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

### 5. 渲染过程中遇到 JS 文件怎么处理？

JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。

### 6. async 和 defer 的作用是什么？有什么区别？

- 脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
- defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，DOMContentLoaded 事件触发之前完成。**多个脚本按顺序执行**。
- async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。**多个脚本的执行顺序无法保证**。

### 7. 什么是文档的预解析？

Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。

### 8. CSS 如何阻塞文档解析？

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。

所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，**浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析**。

### 9. 渲染页面时常见哪些不良现象？

- **FOUC**：主要指的是样式闪烁的问题。由于浏览器渲染机制（比如 firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。
- **白屏**：有些浏览器渲染机制（比如 chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。

### 10. 什么是重绘和回流？

- **重绘**: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如`background-color`，我们将这样的操作称为重绘。
- **回流**：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

### 11. 如何减少回流？

1. 使用`transform`替代`top`。
2. 不要把节点的属性值放在一个循环里当成循环里的变量。
3. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。
4. 把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM。
5. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。

### 12. DOMContentLoaded 事件和 Load 事件的区别？

当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。

Load 事件是当所有资源加载完成后触发的。

### 13. 如何实现浏览器内多个标签页之间的通信?

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。

第二种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。

### 14. 页面可见性（Page Visibility API）可以有哪些用途？

这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。

- 对服务器的轮询
- 网页动画
- 正在播放的音频或视频

### 15. 前端性能优化？

第一个方面是页面的内容方面

- 通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
- 通过 DNS 缓存等机制来减少 DNS 的查询次数。
- 通过设置缓存策略，对常用不变的资源进行缓存。
- 使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
- 通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

第二个方面是服务器方面

- 使用 CDN 服务，来提高用户对于资源请求时的响应速度。
- 服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
- 尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie。

第三个方面是 CSS 和 JavaScript 方面

- 把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
- 避免使用 @import 标签。
- 尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
- 通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。

### 16. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？

核心过程是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。
