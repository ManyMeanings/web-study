- [一些概念](#一些概念)
  - [1. 对浏览器内核的理解？](#1-对浏览器内核的理解)
  - [2. 常见浏览器内核比较](#2-常见浏览器内核比较)
  - [3. 浏览器的渲染原理？&#10084;](#3-浏览器的渲染原理)
  - [4. 渲染过程中遇到 JS 文件怎么处理？](#4-渲染过程中遇到-js-文件怎么处理)
  - [5. async 和 defer 的作用是什么？有什么区别？&#10084;](#5-async-和-defer-的作用是什么有什么区别)
  - [6. 什么是文档的预解析？](#6-什么是文档的预解析)
  - [7. CSS 如何阻塞文档解析？](#7-css-如何阻塞文档解析)
  - [8. 渲染页面时常见哪些不良现象？](#8-渲染页面时常见哪些不良现象)
  - [9. 什么是重绘和回流（重排）？&#10084;](#9-什么是重绘和回流重排)
  - [10. 如何减少回流？](#10-如何减少回流)
  - [11. DOMContentLoaded 事件和 Load 事件的区别？](#11-domcontentloaded-事件和-load-事件的区别)
  - [12. 如何实现浏览器内多个标签页之间的通信?](#12-如何实现浏览器内多个标签页之间的通信)
  - [13. 页面可见性（Page Visibility API）可以有哪些用途？](#13-页面可见性page-visibility-api可以有哪些用途)
  - [14. 前端性能优化？&#10084;](#14-前端性能优化)
  - [15. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？](#15-扫描二维码登录网页是什么原理前后两个事件是如何联系的)
  - [16. 简单谈一下 cookie ？](#16-简单谈一下-cookie-)
  - [17. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？](#17-什么是前端路由什么时候适合使用前端路由前端路由有哪些优点和缺点)
  - [18. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？](#18-什么是-mvvm比之-mvc-有什么区别什么又是-mvp-)
  - [19. 面向对象开发的相关概念](#19-面向对象开发的相关概念)
  - [20. 对 js 中堆栈的理解？](#20-对-js-中堆栈的理解)
  - [21. 进程和线程的区别？](#21-进程和线程的区别)
  - [22.浏览器安全相关](#22浏览器安全相关)
- [计算机网络](#计算机网络)
  - [1. Post 和 Get 的区别？&#10084;](#1-post-和-get-的区别)
  - [2. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？&#10084;](#2-当你在浏览器中输入-googlecom-并且按下回车之后发生了什么)
  - [3. 谈谈 CDN 服务？&#10084;](#3-谈谈-cdn-服务)
  - [4. HTTP 协议的主要特点&#10084;](#4-http-协议的主要特点)
  - [5. HTTP 报文的组成部分&#10084;](#5-http-报文的组成部分)
  - [6. HTTP 方法&#10084;](#6-http-方法)
  - [7. HTTP 常用状态码？&#10084;](#7-http-常用状态码)
  - [8. TCP 和 UDP 的区别？](#8-tcp-和-udp-的区别)
  - [9. HTTPS 加密的方法？](#9-https-加密的方法)
  - [10. http 头部字段？](#10-http-头部字段)
  - [11. TCP 建立连接和释放连接的过程？](#11-tcp-建立连接和释放连接的过程)

## 一些概念

### 1. 对浏览器内核的理解？

主要分成两部分：渲染引擎和 JS 引擎。

渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件浏览器扩展显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。

JS 引擎：解析和执行 javascript 来实现网页的动态效果。

### 2. 常见浏览器内核比较

-   **Trident**：IE 浏览器用的内核，由于早期 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决.
-   **Presto**：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快 3 倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。
-   **Gecko**：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。
-   **Webkit**：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。
-   **Blink**：Blink 是 Webkit 的一个分支。Blink 现在是谷歌公司与 Opera Software 共同研发。Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。

### 3. 浏览器的渲染原理？&#10084;

1. 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
2. 然后对 CSS 进行解析，生成 CSSOM（CSS Object Model）。
3. 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应。
4. 计算布局：当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
5. 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

### 4. 渲染过程中遇到 JS 文件怎么处理？

JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。

### 5. async 和 defer 的作用是什么？有什么区别？&#10084;

-   脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
-   defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，DOMContentLoaded 事件触发之前完成。**多个脚本按顺序执行**。
-   async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。**多个脚本的执行顺序无法保证**。

### 6. 什么是文档的预解析？

Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。

### 7. CSS 如何阻塞文档解析？

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。

所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，**浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析**。

### 8. 渲染页面时常见哪些不良现象？

-   **FOUC**：主要指的是样式闪烁的问题。由于浏览器渲染机制（比如 firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。
-   **白屏**：有些浏览器渲染机制（比如 chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。

### 9. 什么是重绘和回流（重排）？&#10084;

-   **重绘**: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如`background-color`，我们将这样的操作称为重绘。
-   **回流（重排）**：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

### 10. 如何减少回流？

1. 不要把节点的属性值放在一个循环里当成循环里的变量。
2. 把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM。
3. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
4. 使用虚拟 DOM（virtual DOM）库。

### 11. DOMContentLoaded 事件和 Load 事件的区别？

当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。

Load 事件是当所有资源加载完成后触发的。

### 12. 如何实现浏览器内多个标签页之间的通信?

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。

第二种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。

### 13. 页面可见性（Page Visibility API）可以有哪些用途？

这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。

-   对服务器的轮询
-   网页动画
-   正在播放的音频或视频

### 14. 前端性能优化？&#10084;

第一个方面是页面的内容方面

-   通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
-   通过设置缓存策略，对常用不变的资源进行缓存。
-   使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
-   通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

第二个方面是服务器方面

-   使用 CDN 服务，来提高用户对于资源请求时的响应速度。
-   服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
-   尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie。

第三个方面是 CSS 和 JavaScript 方面

-   把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
-   避免使用 @import 标签。
-   尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
-   通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。

### 15. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？

核心过程是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。

### 16. 简单谈一下 cookie ？

cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条 cookie 包括了 5 个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path 是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。

### 17. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？

1. 什么是前端路由？

前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。

2. 什么时候使用前端路由？

在单页面应用，大部分页面结构不变，只改变部分内容的使用

3. 前端路由有什么优点和缺点？

优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户

缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置

### 18. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？

MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。

MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。

MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的 Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。

MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。

### 19. 面向对象开发的相关概念

-   类（Class）：定义了一件事物的抽象特点，包含它的属性和方法
-   对象（Object）：类的实例，通过 new 生成
-   面向对象（OOP）的三大特性：封装、继承、多态
-   封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据
-   继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性
-   多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat
-   存取器（getter & setter）：用以改变属性的读取和赋值行为
-   修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法
-   抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
-   接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口

### 20. 对 js 中堆栈的理解？

**栈：**

-   先进后出的数据结构
-   存储基础数据类型
-   按值访问，存储的值的大小固定

**堆：**

-   无序存储，根据引用直接获取
-   存储引用数据类型
-   按引用访问，存储的值大小不定，可动态调整

### 21. 进程和线程的区别？

-   进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
-   线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

### 22.浏览器安全相关

**sql 注入：**

把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，欺骗服务器执行恶意的 SQL 命令。

防范方法：

-   对用户输入进行校验和转义
-   不要动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取
-   加密处理用户的机密信息

**XSS 攻击：**

攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

防范方法：

1. 提交恶意代码的时候：对存入数据库的数据提前做好校验和转义处理
2. 浏览器执行恶意代码的时候：对需要插入 html 的代码做好转义处理，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断；使用浏览器 csp 白名单；验证码区分脚本。

**CSRF 攻击：**

CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

## 计算机网络

### 1. Post 和 Get 的区别？&#10084;

1. 浏览器在回退时，get 不会重新请求，但是 post 会重新请求。【重要】
2. get 请求会被浏览器主动缓存，而 post 不会。【重要】
3. get 请求的参数，会报保留在浏览器的历史记录里，而 post 不会。做业务时要注意。为了防止 CSRF 攻击，很多公司把 get 统一改成了 post。
4. get 请求在 url 中传递的参数有大小限制，基本是 2kb，不同的浏览器略有不同。而 post 没有注意。
5. get 的参数是直接暴露在 url 上的，相对不安全。而 post 是放在请求体中的。

### 2. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？&#10084;

1. URL 解析：判断输入的是合法的 URL 还是待搜索的关键词，根据输入的内容进行自动完成，安全检查等操作。
2. 浏览器缓存：浏览器查看有无缓存，如果有缓存是否在有效期内，不满足则进入下一步。
3. DNS 查询：检查是否在缓存中，如果没有就将域名发送到本地域名服务器通过递归查询和迭代查询获得 IP 地址并缓存。
4. 建立连接：通过三次握手建立 TCP 连接并发送 http 请求。（如果是 https？）
5. 处理请求：服务器收到请求后交给后台程序处理，根据请求格式返回对应的资源。
6. 渲染页面：浏览器根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSS 规则树，然后根据它们来构建渲染树，根据渲染树来进行布局。布局完成后，使用浏览器的 UI 接口对页面进行绘制。同时看情况加载和运行 js 脚本。

### 3. 谈谈 CDN 服务？&#10084;

CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。

### 4. HTTP 协议的主要特点&#10084;

-   简单快速：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在 http 协议中，处理起来也比较简单，想访问什么资源，直接输入 url 即可。
-   灵活：http 协议的头部有一个数据类型，通过 http 协议，就可以完成不同数据类型的传输。
-   无连接：连接一次，就会断开，不会继续保持连接。
-   无状态：客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。

### 5. HTTP 报文的组成部分&#10084;

http 报文包括请求报文和响应报文。

请求报文包括：

-   请求行：包括请求方法、请求的 url、http 协议及版本。
-   请求头：一大堆的键值对。
-   空行：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。
-   请求体：数据部分。

响应报文包括：

-   状态行：http 协议及版本、状态码及状态描述。
-   响应头
-   空行
-   响应体

### 6. HTTP 方法&#10084;

-   GET：获取资源
-   POST：传输资源
-   put：更新资源
-   DELETE：删除资源
-   HEAD：获得报文首部

### 7. HTTP 常用状态码？&#10084;

-   100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认。
-   200 OK 正常返回信息。
-   201 Created 请求成功并且服务器创建了新的资源。
-   202 Accepted 服务器已接受请求，但尚未处理。
-   301 Moved Permanently 请求的网页已永久移动到新位置。
-   302 Found 要求客户端执行临时重定向。
-   303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。
-   304 Not Modified 自从上次请求后，请求的网页未修改过。
-   400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
-   401 Unauthorized 请求未授权。
-   403 Forbidden 禁止访问。
-   404 Not Found 找不到如何与 URI 相匹配的资源。
-   500 Internal Server Error 最常见的服务器端错误。
-   503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

### 8. TCP 和 UDP 的区别？

TCP（传输控制协议）是面向连接的协议，通过“三次握手”建立可靠的链接，保证数据包的顺序，提供全双工通信。（可靠有序，不丢不重）

UDP（用户数据报协议）是无连接的，不可靠的传输层协议，不保证数据的可靠交付，不保证数据包的顺序，没有拥塞控制，适合很多实时应用。

### 9. HTTPS 加密的方法？

**http 协议存在的问题：**

-   通信使用明文
-   无法证明报文的完整性
-   不验证通信方的身份

**https 的做法：**

发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。使用数字证书保证通信方身份的真实性。（对称加密：加密解密使用一个密钥；非对称加密：发送方使用公钥加密，接收方使用私钥解密）

1. 客户端发起一个 https 请求。
2. 服务器收到请求后返回一个配置好的数字证书。
3. 客户端对数字证书进行验证，通过则继续，不通过则显示警告信息。
4. 客户端使用伪随机数生成器生成加密所需要的对称密钥，使用数字证书上的公钥加密这个对称密钥，发送给服务器。
5. 服务器使用私钥解密这个消息，得到对称密钥。
6. 之后双方通讯都使用这个对称密钥加密和解密明文。

### 10. http 头部字段？

**通用头：**

-   Connection：允许客户端和服务器指定与请求/响应连接有关的选项
-   Date：提供日期和时间标志
-   Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式
-   Cache-Control：max-age/no-cache/no-store/private... 用于随报文传送缓存指示

**请求头：**

-   Host：服务器的域名和端口
-   User-agent：客户端的一些信息，浏览器信息、版本等
-   Referer：当前请求页面的来源页面的地址
-   Cookie：向服务器传送数据
-   Authorization：客户端提供给服务器，以便对其自身进行认证的数据

**响应头：**

-   Server：服务器应用程序软件的名称和版本
-   set-Cookie：服务器向客户端设置 cookie
-   Expires：缓存失效时间

### 11. TCP 建立连接和释放连接的过程？

**三次握手：**

1. 客户端要发送一个数据包告诉服务器要建立连接，把控制位 SYN 置为 1。
2. 服务器收到数据包后，为该 TCP 连接分配缓存和变量，返回一个确认报文，其中 SYN 为 1，表示允许建立连接；ACK 为 1，表示确认收到发送方的包。
3. 客户端收到确认报文后，为该 TCP 连接分配缓存和变量，并返回一个确认报文，其中 SYN 为 0，表示要正式发送数据了；ACK 为 1，表示收到确认请求。

**四次挥手：**

1. 客户端请求断开连接，把 FIN 置 1，表示发送方已经完成了数据的发送。
2. 服务器返回一个确认报文，ACK 置 1 表示确认收到，客户端到服务器方向的连接就释放了。
3. 服务器发送完数据，发出连接释放报文，把 FIN 置 1，ACK 置 1。
4. 客户端回送一个确认报文，ACK 置 1，等待两个最长报文寿命，彻底关闭连接。
