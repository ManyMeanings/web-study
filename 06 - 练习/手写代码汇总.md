- [布局](#布局)
  - [水平垂直居中](#水平垂直居中)
  - [清除浮动](#清除浮动)
- [js](#js)
- [算法](#算法)
  - [数组去重](#数组去重)
  - [大整数相加](#大整数相加)
  - [数组扁平化](#数组扁平化)
  - [求数组的最大值和最小值](#求数组的最大值和最小值)
  - [求两个数的最大公约数](#求两个数的最大公约数)
  - [求两个数的最小公倍数](#求两个数的最小公倍数)
  - [使用 reduce 方法实现 forEach、map、filter](#使用-reduce-方法实现-foreachmapfilter)

## 布局

### 水平垂直居中

```css
/*1. 利用绝对定位，设置四个方向的值都为0，并将 margin 设置为 auto */
div {
  position: absolute;
  width: 200px;
  height: 200px;
  margin: auto;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: red;
}

/*2. 利用绝对定位,利用 transform 属性*/
div {
  position: absolute; /*相对定位或绝对定位均可*/
  width: 500px;
  height: 300px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: red;
}

/*3. 利用flex布局*/
.container {
  display: flex;
  align-items: center;
  justify-content: center;
}

div {
  width: 100px;
  height: 100px;
  background-color: red;
}

/*4. flex + margin: auto*/
.father {
  display: flex;
  min-height: 100vh;
  background: pink;
}
.son {
  margin: auto;
  background: red;
}
```

### 清除浮动

```html
<!DOCTYPE html>
<html>
  <head lang="en">
    <meta charset="UTF-8" />
    <title>clear float</title>
    <style>
      ul li {
        float: left;
        width: 100px;
        height: 20px;
      }
      /*1. 给浮动元素的祖先元素设置高度大于浮动元素的高度*/
      ul {
        height: 40px;
      }
      /*2. 隔墙法*/
      .method2 {
        clear: both;
      }
      /*3. 内墙法*/
      .method3 {
        clear: both;
      }
      /*4. 给浮动元素的父元素设置属性overflow: hidden*/
      ul {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <ul>
      <li>item1</li>
      <li>item1</li>
      <li>item1</li>
      <li>item1</li>
      <div class="method3"></div>
    </ul>
    <div class="method2"></div>
    <ul>
      <li>item1</li>
      <li>item1</li>
      <li>item1</li>
      <li>item1</li>
    </ul>
  </body>
</html>
```

## js

## 算法

### 数组去重

方法一：双层循环。新建一个空数组，对于待处理数组的每一项判断新数组里是否已存在，若不存在，则插入新数组。

```js
function unique(arr) {
  if (!Array.isArray(array) || array.length <= 1) return;
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    let flag = true;
    //注意使用push后res数组长度会增加，所以使用for循环时终止条件不能为j<res.length
    //参考写法：for (let j = 0, resLen = res.length; j < resLen; j++ )
    for (let value of res) {
      if (value === arr[i]) {
        flag = false;
        break;
      }
    }
    if (flag) {
      res.push(arr[i]);
    }
  }
  return res;
}
```

方法二：使用`indexOf()`简化内层循环。

```js
function unique(array) {
  if (!Array.isArray(array) || array.length <= 1) return;
  var result = [];
  array.forEach(function (item) {
    //indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1
    if (result.indexOf(item) === -1) {
      result.push(item);
    }
  });
  return result;
}
```

方法三：使用`Set()`构造函数。

```js
function unique(array) {
  if (!Array.isArray(array) || array.length <= 1) return;
  //return [...new Set(array)];
  return Array.from(new Set(arr));
}
```

### 大整数相加

```js
function bigNumberAdd(number1, number2) {
  let result = "", // 保存最后结果
    carry = false; // 保留进位结果
  // 将字符串转换为数组
  number1 = number1.split("");
  number2 = number2.split("");
  // 当数组的长度都变为0，并且最终不再进位时，结束循环
  while (number1.length || number2.length || carry) {
    // 每次将最后的数字进行相加，~~能将字符串转换为数字，使用~~的好处是，即使返回值为 undefined 也能转换为 0
    carry += ~~number1.pop() + ~~number2.pop();
    // 取加法结果的个位加入最终结果
    result = (carry % 10) + result;
    // 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0
    carry = carry > 9;
  }
  // 返回最终结果
  return result;
}
```

### 数组扁平化

```js
function flattenArray(array) {
  if (!Array.isArray(array)) return;
  let result = [];
  result = array.reduce(function (pre, item) {
    // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中
    return pre.concat(Array.isArray(item) ? flattenArray(item) : item);
  }, []);
  return result;
}
```

### 求数组的最大值和最小值

```js
var arr = [6, 4, 1, 8, 2, 11, 23];
console.log(Math.max.apply(null, arr));
console.log(Math.min.apply(null, arr));
```

### 求两个数的最大公约数

基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，直到余数为 0 时，最后的被除数就是两个数的最大公约数。

```js
function getMaxCommonDivisor(a, b) {
  if (b === 0) return a;
  return getMaxCommonDivisor(b, a % b);
}
```

### 求两个数的最小公倍数

基本思想是采用将两个数相乘，然后除以它们的最大公约数

```js
function getMinCommonMultiple(a, b) {
  return (a * b) / getMaxCommonDivisor(a, b);
}
```

### 使用 reduce 方法实现 forEach、map、filter

```js
// forEach
function forEachUseReduce(array, handler) {
  array.reduce(function (pre, item, index) {
    handler(item, index);
  });
}

// map
function mapUseReduce(array, handler) {
  let result = [];
  array.reduce(function (pre, item, index) {
    let mapItem = handler(item, index);
    result.push(mapItem);
  });

  return result;
}

// filter
function filterUseReduce(array, handler) {
  let result = [];
  array.reduce(function (pre, item, index) {
    if (handler(item, index)) {
      result.push(item);
    }
  });
  return result;
}
```
